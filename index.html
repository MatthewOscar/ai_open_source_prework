<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini MMORPG</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let worldImage = new Image();
        let ws = null;
        let gameData = {
            playerId: null,
            players: {},
            avatars: {},
            camera: { x: 0, y: 0 }
        };
        
        // Keyboard state tracking
        const keysPressed = {};
        const keyMapping = {
            'KeyW': 'up',
            'ArrowUp': 'up',
            'KeyA': 'left', 
            'ArrowLeft': 'left',
            'KeyS': 'down',
            'ArrowDown': 'down',
            'KeyD': 'right',
            'ArrowRight': 'right'
        };
        let lastMoveTime = 0;
        const MOVE_THROTTLE_MS = 75; // Send move commands every 75ms (about 13 per second)
        
        // Mouse control state
        let isMouseDragging = false;
        let mouseWorldX = 0;
        let mouseWorldY = 0;
        
        // WebSocket connection
        function connectToServer() {
            ws = new WebSocket('wss://codepath-mmorg.onrender.com');
            
            ws.onopen = function() {
                // console.log('Connected to game server');
                joinGame();
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleServerMessage(message);
            };
            
            ws.onclose = function() {
                // console.log('Disconnected from game server');
                // Attempt reconnection after 3 seconds
                setTimeout(connectToServer, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }
        
        // Join the game
        function joinGame() {
            const joinMessage = {
                action: "join_game",
                username: "Matthew"
            };
            ws.send(JSON.stringify(joinMessage));
        }
        
        // Handle messages from server
        function handleServerMessage(message) {
            // console.log('Received message:', message);
            
            switch(message.action) {
                case 'join_game':
                    if (message.success) {
                        gameData.playerId = message.playerId;
                        gameData.players = message.players;
                        gameData.avatars = message.avatars;
                        loadAvatarImages();
                        updateCamera();
                        drawWorld();
                    } else {
                        console.error('Failed to join game:', message.error);
                    }
                    break;
                    
                case 'players_moved':
                    // Update player positions with smooth interpolation
                    for (const playerId in message.players) {
                        if (gameData.players[playerId]) {
                            const serverPlayer = message.players[playerId];
                            const localPlayer = gameData.players[playerId];
                            
                            // Don't interpolate our own player (we use client-side prediction)
                            if (playerId === gameData.playerId) {
                                // Just update facing and animation state from server
                                localPlayer.facing = serverPlayer.facing;
                                localPlayer.isMoving = serverPlayer.isMoving;
                                localPlayer.animationFrame = serverPlayer.animationFrame;
                            } else {
                                // For other players, set up smooth interpolation
                                localPlayer.targetX = serverPlayer.x;
                                localPlayer.targetY = serverPlayer.y;
                                localPlayer.facing = serverPlayer.facing;
                                localPlayer.isMoving = serverPlayer.isMoving;
                                localPlayer.animationFrame = serverPlayer.animationFrame;
                                
                                // If no current interpolation, snap to position
                                if (!localPlayer.interpolating) {
                                    localPlayer.x = serverPlayer.x;
                                    localPlayer.y = serverPlayer.y;
                                }
                            }
                        }
                    }
                    updateCamera();
                    drawWorld();
                    break;
                    
                case 'player_joined':
                    gameData.players[message.player.id] = message.player;
                    if (message.avatar) {
                        gameData.avatars[message.avatar.name] = message.avatar;
                        loadAvatarImages();
                    }
                    drawWorld();
                    break;
                    
                case 'player_left':
                    delete gameData.players[message.playerId];
                    drawWorld();
                    break;
                    
                default:
                    console.log('Unknown message type:', message.action, message);
            }
        }
        
        // Send move command to server
        function sendMoveCommand(direction) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const moveMessage = {
                    action: "move",
                    direction: direction
                };
                ws.send(JSON.stringify(moveMessage));
                
                // Client-side prediction: move our player immediately
                predictPlayerMovement(direction);
            }
        }
        
        // Predict player movement locally for smooth feel
        function predictPlayerMovement(direction) {
            if (!gameData.playerId || !gameData.players[gameData.playerId]) {
                return;
            }
            
            const player = gameData.players[gameData.playerId];
            const moveSpeed = 25; // Fast and responsive movement
            
            // Move player locally based on direction
            switch(direction) {
                case 'up':
                    player.y = Math.max(0, player.y - moveSpeed);
                    player.facing = 'north';
                    break;
                case 'down':
                    player.y = Math.min(2048 - 32, player.y + moveSpeed); // Assuming avatar is ~32px tall
                    player.facing = 'south';
                    break;
                case 'left':
                    player.x = Math.max(0, player.x - moveSpeed);
                    player.facing = 'west';
                    break;
                case 'right':
                    player.x = Math.min(2048 - 32, player.x + moveSpeed); // Assuming avatar is ~32px wide
                    player.facing = 'east';
                    break;
            }
            
            player.isMoving = true;
            updateCamera();
            drawWorld();
        }
        
        // Game loop for continuous movement
        function gameLoop() {
            const currentTime = Date.now();
            
            // Interpolate other players' positions for smooth movement
            interpolatePlayerPositions();
            
            // Only send move commands if enough time has passed (throttling)
            if (currentTime - lastMoveTime >= MOVE_THROTTLE_MS) {
                let commandSent = false;
                
                // Priority 1: Mouse dragging (overrides keyboard)
                if (isMouseDragging) {
                    sendMoveToPosition(mouseWorldX, mouseWorldY);
                    commandSent = true;
                } else {
                    // Priority 2: Keyboard movement (only when not dragging)
                    for (const key in keysPressed) {
                        if (keysPressed[key] && keyMapping[key]) {
                            sendMoveCommand(keyMapping[key]);
                            commandSent = true;
                            break; // Only send one direction per throttle period
                        }
                    }
                }
                
                if (commandSent) {
                    lastMoveTime = currentTime;
                }
            }
            
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }
        
        // Send move-to-position command (for mouse control)
        function sendMoveToPosition(worldX, worldY) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const moveMessage = {
                    action: "move",
                    x: worldX,
                    y: worldY
                };
                ws.send(JSON.stringify(moveMessage));
                
                // Client-side prediction for mouse movement too
                predictPlayerMovementToward(worldX, worldY);
            }
        }
        
        // Predict movement toward a target position
        function predictPlayerMovementToward(targetX, targetY) {
            if (!gameData.playerId || !gameData.players[gameData.playerId]) {
                return;
            }
            
            const player = gameData.players[gameData.playerId];
            const dx = targetX - player.x;
            const dy = targetY - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) { // Only move if we're not already close
                const moveSpeed = 25; // Same speed as keyboard movement
                const moveX = (dx / distance) * moveSpeed;
                const moveY = (dy / distance) * moveSpeed;
                
                player.x += moveX;
                player.y += moveY;
                
                // Set facing direction based on movement
                if (Math.abs(dx) > Math.abs(dy)) {
                    player.facing = dx > 0 ? 'east' : 'west';
                } else {
                    player.facing = dy > 0 ? 'south' : 'north';
                }
                
                player.isMoving = true;
                updateCamera();
                drawWorld();
            }
        }
        
        // Smooth interpolation for other players
        function interpolatePlayerPositions() {
            let needsRedraw = false;
            
            for (const playerId in gameData.players) {
                if (playerId === gameData.playerId) continue; // Skip our own player
                
                const player = gameData.players[playerId];
                if (player.targetX !== undefined && player.targetY !== undefined) {
                    const dx = player.targetX - player.x;
                    const dy = player.targetY - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 1) {
                        // Move towards target at a fixed speed
                        const speed = 3; // Adjust for smoothness
                        const moveX = (dx / distance) * speed;
                        const moveY = (dy / distance) * speed;
                        
                        player.x += moveX;
                        player.y += moveY;
                        player.interpolating = true;
                        needsRedraw = true;
                    } else {
                        // Close enough, snap to target
                        player.x = player.targetX;
                        player.y = player.targetY;
                        player.interpolating = false;
                    }
                }
            }
            
            if (needsRedraw) {
                drawWorld();
            }
        }
        
        // Load avatar images from base64 data
        function loadAvatarImages() {
            for (const avatarName in gameData.avatars) {
                const avatar = gameData.avatars[avatarName];
                avatar.imageObjects = {};
                
                // Load images for each direction
                for (const direction in avatar.frames) {
                    avatar.imageObjects[direction] = [];
                    
                    avatar.frames[direction].forEach((base64Data, frameIndex) => {
                        const img = new Image();
                        img.onload = function() {
                            // console.log(`Loaded avatar ${avatarName} ${direction} frame ${frameIndex}`);
                            drawWorld();
                        };
                        img.src = base64Data;
                        avatar.imageObjects[direction].push(img);
                    });
                }
            }
        }
        
        // Update camera position based on player location
        function updateCamera() {
            if (!gameData.playerId || !gameData.players[gameData.playerId]) {
                return;
            }
            
            const player = gameData.players[gameData.playerId];
            const worldSize = 2048;
            
            // Center camera on player, but don't go past world boundaries
            gameData.camera.x = Math.max(0, Math.min(
                worldSize - canvas.width,
                player.x - canvas.width / 2
            ));
            gameData.camera.y = Math.max(0, Math.min(
                worldSize - canvas.height,
                player.y - canvas.height / 2
            ));
        }
        
        // Set canvas size to fill window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateCamera();
            drawWorld();
        }
        
        // Draw a single avatar
        function drawAvatar(player) {
            const avatar = gameData.avatars[player.avatar];
            if (!avatar || !avatar.imageObjects) {
                return;
            }
            
            // Get the correct direction and frame
            let direction = player.facing;
            if (direction === 'west') {
                // Use east frames but flip horizontally
                direction = 'east';
            }
            
            const frames = avatar.imageObjects[direction];
            if (!frames || frames.length === 0) {
                return;
            }
            
            const frameIndex = Math.min(player.animationFrame || 0, frames.length - 1);
            const img = frames[frameIndex];
            
            if (!img || !img.complete) {
                return;
            }
            
            // Calculate screen position
            const screenX = player.x - gameData.camera.x;
            const screenY = player.y - gameData.camera.y;
            
            // Save context for potential flipping
            ctx.save();
            
            // Handle west direction flipping
            if (player.facing === 'west') {
                ctx.scale(-1, 1);
                ctx.drawImage(img, -(screenX + img.width), screenY);
            } else {
                ctx.drawImage(img, screenX, screenY);
            }
            
            ctx.restore();
            
            // Draw username label above avatar
            ctx.save();
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            const labelX = screenX + img.width / 2;
            const labelY = screenY - 5;
            
            // Draw text outline
            ctx.strokeText(player.username, labelX, labelY);
            // Draw text fill
            ctx.fillText(player.username, labelX, labelY);
            
            ctx.restore();
        }
        
        // Draw all avatars
        function drawAvatars() {
            for (const playerId in gameData.players) {
                const player = gameData.players[playerId];
                drawAvatar(player);
            }
        }
        
        // Load and draw the world map
        function drawWorld() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (worldImage.complete) {
                // Draw the world image with camera offset
                ctx.drawImage(
                    worldImage,
                    gameData.camera.x, gameData.camera.y, canvas.width, canvas.height,
                    0, 0, canvas.width, canvas.height
                );
            }
            
            // Draw avatars on top of the world
            drawAvatars();
            
            // Draw mouse target if dragging
            if (isMouseDragging) {
                drawMouseTarget();
            }
        }
        
        // Draw visual indicator for mouse target
        function drawMouseTarget() {
            const screenX = mouseWorldX - gameData.camera.x;
            const screenY = mouseWorldY - gameData.camera.y;
            
            // Only draw if target is visible on screen
            if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                ctx.save();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // Draw a circle at the target position
                ctx.beginPath();
                ctx.arc(screenX, screenY, 10, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // Keyboard event handlers
        function setupKeyboardControls() {
            document.addEventListener('keydown', function(event) {
                if (keyMapping[event.code]) {
                    keysPressed[event.code] = true;
                    event.preventDefault(); // Prevent page scrolling
                }
            });
            
            document.addEventListener('keyup', function(event) {
                if (keyMapping[event.code]) {
                    keysPressed[event.code] = false;
                }
            });
            
            // Handle window focus/blur to prevent stuck keys
            window.addEventListener('blur', function() {
                // Clear all pressed keys when window loses focus
                for (const key in keysPressed) {
                    keysPressed[key] = false;
                }
            });
        }
        
        // Mouse control setup
        function setupMouseControls() {
            canvas.addEventListener('mousedown', function(event) {
                isMouseDragging = true;
                updateMouseWorldPosition(event);
            });
            
            canvas.addEventListener('mousemove', function(event) {
                if (isMouseDragging) {
                    updateMouseWorldPosition(event);
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                isMouseDragging = false;
            });
            
            // Handle mouse leaving canvas
            canvas.addEventListener('mouseleave', function() {
                isMouseDragging = false;
            });
        }
        
        // Convert screen coordinates to world coordinates
        function updateMouseWorldPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            
            // Convert to world coordinates
            mouseWorldX = screenX + gameData.camera.x;
            mouseWorldY = screenY + gameData.camera.y;
            
            // Clamp to world boundaries
            mouseWorldX = Math.max(0, Math.min(2048, mouseWorldX));
            mouseWorldY = Math.max(0, Math.min(2048, mouseWorldY));
        }
        
        // Initialize the game
        function init() {
            // Load the world image
            worldImage.onload = function() {
                drawWorld();
            };
            worldImage.src = 'world.jpg';
            
            // Set up canvas resize handler
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Set up keyboard controls
            setupKeyboardControls();
            
            // Set up mouse controls
            setupMouseControls();
            
            // Start the game loop
            gameLoop();
            
            // Connect to game server
            connectToServer();
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>